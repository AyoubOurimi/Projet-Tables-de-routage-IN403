import random
import networkx as nx
import heapq
import tkinter as tk
from tkinter import ttk
from tkinter.scrolledtext import ScrolledText

# Création du graphe
graphe = nx.Graph()

# Ajout des nœuds du backbone (Tier 1)
noeuds_backbone = range(1, 11)
graphe.add_nodes_from(noeuds_backbone, niveau=1)

# Création des arêtes du backbone avec une probabilité de 75%
for u in noeuds_backbone:
    for v in noeuds_backbone:
        if u < v and random.random() < 0.75:
            poids = random.randint(5, 10)  # Plage de poids pour le Tier 1
            graphe.add_edge(u, v, poids=poids)

# Ajout des opérateurs de niveau 2 (Tier 2)
noeuds_tier2 = range(11, 31)
graphe.add_nodes_from(noeuds_tier2, niveau=2)

for noeud in noeuds_tier2:
    voisins_backbone = random.sample(noeuds_backbone, random.randint(1, 2))
    for voisin in voisins_backbone:
        poids = random.randint(10, 20)  # Plage de poids pour le Tier 2
        graphe.add_edge(noeud, voisin, poids=poids)

# Ajout des opérateurs de niveau 3 (Tier 3)
noeuds_tier3 = range(31, 101)
graphe.add_nodes_from(noeuds_tier3, niveau=3)

for noeud in noeuds_tier3:
    voisins_tier2 = random.sample(noeuds_tier2, 2)
    for voisin in voisins_tier2:
        poids = random.randint(20, 50)  # Plage de poids pour le Tier 3
        graphe.add_edge(noeud, voisin, poids=poids)

# Algorithme de Dijkstra pour trouver le chemin le plus court entre deux nœuds
def dijkstra(graphe, depart):
    # Initialisation des distances avec une valeur infinie pour tous les nœuds
    distances = {noeud: float('inf') for noeud in graphe}
    distances[depart] = 0
    
    # Liste pour stocker les nœuds visités
    visites = set()
    
    while visites != set(graphe):
        # Trouver le nœud non visité avec la distance minimale
        noeud_actuel = min((noeud for noeud in graphe if noeud not in visites), key=lambda n: distances[n])
        visites.add(noeud_actuel)
        
        # Mettre à jour les distances pour les voisins du nœud actuel
        for voisin, data_arete in graphe[noeud_actuel].items():
            poids = data_arete['poids']
            distance = distances[noeud_actuel] + poids
            
            if distance < distances[voisin]:
                distances[voisin] = distance
    
    return distances

# fonction qui va afficher la table de routage d'un nœud sélectionné
def afficher_table_routage():
    noeud_selectionne = int(variable_noeud.get())
    table_routage = dijkstra(graphe, noeud_selectionne)
    info_table.set(str(table_routage))
    
    zone_texte.delete('1.0', tk.END)  # efface le contenu précédent
    zone_texte.insert(tk.END, table_routage)  # insere la nouvelle table de routage

racine = tk.Tk()
racine.title("Table de routage")

# cadre principal(conteneur de widgets)
cadre_principal = ttk.Frame(racine, padding="20")
cadre_principal.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))

# liste deroulante qui va nous permettre pour choisir un noueud 
variable_noeud = tk.StringVar()
etiquette_noeud = ttk.Label(cadre_principal, text="Sélectionner un nœud :")
etiquette_noeud.grid(row=0, column=0, sticky=tk.W)

combobox_noeud = ttk.Combobox(cadre_principal, textvariable=variable_noeud, state="readonly")
combobox_noeud['values'] = list(graphe.nodes)
combobox_noeud.grid(row=0, column=1, padx=(10))

# boutton qui va nous permettre d'afficher la table de routage dans la barre de texte
bouton_afficher = ttk.Button(cadre_principal, text="Afficher la table de routage", command=afficher_table_routage)
bouton_afficher.grid(row=0, column=2, padx=(10,0))

# zone de texte ou on va afficher la table de routage
info_table = tk.StringVar()
info_table.set("")
etiquette_table = ttk.Label(cadre_principal, text="Table de routage :")
etiquette_table.grid(row=1, column=0, sticky=tk.W, pady=(10))

zone_texte = ScrolledText(cadre_principal, width=40, height=10)  # Pas de textvariable ici
zone_texte.grid(row=2, column=0, columnspan=3, pady=(0,10))


# taille de la fenetre
largeur_fenetre = 480
hauteur_fenetre = 300

# obtenir les dimensions de l'écran
largeur_ecran = racine.winfo_screenwidth()
hauteur_ecran = racine.winfo_screenheight()

# on calculer les coordonnees x et y pour centrer la fenêtre
x = (largeur_ecran // 2) - (largeur_fenetre // 2)
y = (hauteur_ecran // 2) - (hauteur_fenetre // 2)

# Définir la géométrie de la fenêtre pour la centrer

racine.geometry(f"{largeur_fenetre}x{hauteur_fenetre}+{x}+{y}")

racine.mainloop()
